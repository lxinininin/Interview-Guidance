## 浏览器中输入“www.baidu.com” 之后都发生了什么? 请详细阐述

1.  **DNS 解析**：

    -   浏览器首先检查本地 DNS 缓存，如果其中有对应的 IP 地址，则直接使用缓存的 IP 地址。

    -   如果本地缓存没有相应的 IP 地址，则浏览器将发起 DNS 查询，向本地 DNS 服务器请求解析 "[www.baidu.com](http://www.baidu.com)" 的 IP 地址。

    -   如果本地 DNS 服务器也没有相应的解析结果，则它会向根域名服务器发起请求，根域名服务器返回顶级域名服务器的 IP 地址。

    -   然后本地 DNS 服务器向顶级域名服务器发起请求，顶级域名服务器返回二级域名服务器的 IP 地址。

    -   最后，本地 DNS 服务器向二级域名服务器发起请求，获取到"[www.baidu.com](http://www.baidu.com)" 对应的 IP 地址，并将结果返回给浏览器。

        **本地DNS缓存---->本地DNS服务器---->根域名服务器---->顶级域名服务器---->二级域名服务器**

2.  **建立 TCP 连接**：

    -   浏览器使用 HTTP 协议默认的端口号（80）向获取到的 IP 地址发起 TCP 连接请求。
    -   在三次握手之后，建立起 TCP 连接。

3.  **发起 HTTP 请求**：

    -   浏览器向服务器发送一个 HTTP GET 请求，请求页面的资源，请求报文中包含了请求的方法、URI、HTTP 版本号等信息。

4.  **服务器处理请求**：

    -   服务器接收到请求后，根据请求的 URI 找到相应的资源（在这种情况下，就是百度首页）。
    -   服务器处理请求，可能会涉及到数据库查询、动态内容生成等操作，然后将相应的数据打包成      HTTP 响应报文。

5.  **发送 HTTP 响应**：

    -   服务器将 HTTP 响应报文发送回浏览器，响应报文包含了状态码、响应头和响应体等信息。

6.  **浏览器接收响应**：

    -   浏览器接收到响应后，会根据响应头中的内容类型判断如何处理响应体。通常情况下，浏览器会渲染 HTML 内容并呈现给用户。

7.  **关闭 TCP 连接**：

    -   当浏览器接收完响应并渲染页面后，会关闭与服务器的 TCP 连接，释放资源。

8.  **资源加载**：

    -   浏览器在接收到 HTML 页面后，会解析页面，识别其中的其他资源（例如图片、CSS 文件、JavaScript 文件等）的 URL。
    -   浏览器会发起对这些资源的额外请求，并重复上述步骤来获取和处理这些资源。



## HTTP 1.0 和 HTTP 1.1 的主要区别

1.  **持久连接（Persistent Connections）**：
    -   HTTP 1.0 默认情况下是非持久连接的，每个请求/响应都会建立一个新的TCP连接，请求完成后连接会立即关闭。
    -   HTTP 1.1 引入了持久连接的概念，允许在单个连接上发送和接收多个请求和响应，从而减少了连接建立和断开的开销，提高了性能。
2.  **管道化（Pipelining**）：
    -   HTTP 1.1 支持管道化，即在同一个持久连接上可以同时发送多个请求，而无需等待前一个请求的响应。这样可以减少网络延迟，提高性能。
    -   HTTP 1.0 不支持管道化，每个请求必须等待前一个请求的响应才能发送。
3.  **Host头部（Host Header）**：
    -   HTTP 1.1 引入了Host头部，允许一个服务器上托管多个域名，通过Host头部来指示请求的目标主机。
    -   HTTP 1.0 不支持Host头部，因此无法在一个服务器上托管多个域名。
4.  **缓存控制（Cache Control）**：
    -   HTTP 1.1 引入了更强大的缓存控制机制，包括Cache-Control头部，允许客户端和服务器更精细地控制缓存行为。
    -   HTTP 1.0 的缓存控制机制相对简单，主要通过Expires头部来控制缓存时间。
5.  **错误处理（Error Handling）**：
    -   HTTP 1.1 在错误处理方面更加严格和明确，定义了更多的状态码和错误处理机制。
    -   HTTP 1.0 的错误处理相对简单，状态码的定义也较少。



## HTTP 和 HTTPS 的区别

1.  **安全性**：
    -   HTTP是一种明文传输协议，数据在传输过程中是未加密的，因此容易受到中间人攻击（Man-in-the-Middle Attacks）的威胁。这意味着攻击者可以拦截、窃听和篡改HTTP传输的数据。
    -   HTTPS通过使用SSL（Secure Socket Layer）或TLS（Transport Layer Security）协议对数据进行加密，从而保证数据在传输过程中的安全性。加密的数据在传输过程中是不容易被窃听和篡改的，因此HTTPS能够有效防止中间人攻击。
2.  **协议和端口**：
    -   HTTP默认使用端口80进行通信，而HTTPS默认使用端口443。因此，通过URL来区分HTTP和HTTPS的方式是通过观察端口号。
3.  **证书**：
    -   HTTPS需要使用SSL/TLS证书来验证服务器的身份，以确保客户端与服务器之间的通信是安全的。这些证书由受信任的第三方机构（称为证书颁发机构，Certificate Authorities，简称CA）颁发，证明了服务器的身份。客户端可以通过验证证书来确认连接是否安全和可信。
    -   HTTP不需要证书，因为它不提供加密和身份验证。
4.  **性能**：
    -   由于HTTPS需要进行加密和解密操作，因此通常比HTTP稍微慢一些。但是随着计算能力的提高和SSL/TLS协议的优化，这种性能差异正在逐渐减小。

总的来说，HTTPS相比于HTTP在安全性方面更加可靠，适用于对数据保密性和完整性要求较高的场景，如在线支付、用户登录等。



## HTTPS 建立连接的流程

1.  客户端发起连接请求：客户端（例如浏览器）向服务器发起连接请求。这个请求是通过URL中的https://来标识的，这告诉服务器客户端希望使用HTTPS协议与其通信。
2.  服务器端响应：服务器接收到客户端的连接请求后，会向客户端发送一个SSL证书。该证书包含了服务器的公钥、证书的颁发者、证书的有效期等信息。
3.  客户端验证证书：客户端收到服务器发送的SSL证书后，会验证证书的有效性。这个过程包括检查证书是否由可信的证书颁发机构颁发，证书是否在有效期内，以及证书中包含的域名是否与访问的域名匹配等。
4.  客户端生成随机密钥：如果证书验证通过，客户端会生成一个随机的对称密钥，用于后续的数据加密和解密。
5.  客户端使用服务器公钥加密密钥：客户端使用服务器发送的SSL证书中包含的公钥对生成的随机密钥进行加密，并将加密后的密钥发送给服务器。
6.  服务器使用私钥解密密钥：服务器收到客户端发送的加密密钥后，使用自己的私钥对其进行解密，得到对称密钥。
7.  双方建立加密通道：客户端和服务器双方都拥有了相同的对称密钥，它们可以使用这个密钥来加密和解密在通信过程中传输的数据。这样建立的加密通道保证了数据在传输过程中的机密性和完整性。
8.  安全通信：客户端和服务器现在可以通过建立的加密通道安全地进行通信，客户端发送的数据将会被加密后传输到服务器，服务器接收到数据后使用对称密钥进行解密，反之亦然。



## 如何理解 HTTP 协议是无状态的

HTTP 协议是无状态的, 指的是协议对于事务处理没有记忆能力, 服务器不知道客户端是什么状态. 也就是说, 打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系. HTTP 是一个无状态的面向连接的协议, 无状态不代表 HTTP 不能保持 TCP 连接, 更不能代表 HTTP 使用的是 UDP 协议



## HTTP 响应码有哪些? 分别代表什么含义?

-   200: 成功, Web 服务器成功处理了客户端的请求
-   301: 永久重定向, 当客户端请求一个网址的时候, Web 服务器会将当前请求重定向到另一个网址, 搜索引擎会抓取重定向后网页的内容并且将旧的网址替换为重定向后的网址
-   302: 临时重定向, 搜索引擎会抓取重定向后网页的内容而保留旧的网址, 因为搜索引擎认为重定向后的网址是暂时的
-   400: 客户端请求错误, 多为参数不合法导致 Web 服务器验参失败
-   404: 未找到, Web 服务器找不到资源
-   500: Web 服务器错误, 服务器处理客户端请求的时候发生错误
-   503: 服务不可用, 服务器停机
-   504: 网关超时



## GET 和 POST 的区别

GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：

-   **语义（主要区别）**：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。
-   ...
-   ...