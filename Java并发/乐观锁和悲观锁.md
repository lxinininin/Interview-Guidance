## 乐观锁和悲观锁的理解及如何实现, 有哪些实现方式

1.  **悲观锁**：
    -   <u>悲观锁的核心思想是假设并发访问的情况下会发生冲突，因此在访问共享资源之前先获取锁，确保在任何时候只有一个线程可以访问该资源，其他线程必须等待锁的释放</u>。(总是假设最坏的情况, 每次去拿数据的时候都认为别人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿这个数据就会阻塞直到它拿到锁)
    -   悲观锁常用于保护临界区，例如使用 <u>`synchronized` 关键字或 `ReentrantLock` 类来实现</u>。在进入临界区之前，线程会尝试获取锁；如果锁已经被其他线程持有，则当前线程会被阻塞等待锁的释放。
2.  **乐观锁**：
    -   <u>乐观锁的核心思想是假设并发访问的情况下不会发生冲突，因此不需要在访问共享资源之前获取锁。相反，线程会直接尝试访问共享资源，但在更新共享资源之前会先检查该资源是否被其他线程修改过，如果被修改过则进行相应的处理，例如重试或放弃更新</u>。(顾名思义, 就是很乐观, 每次去拿数据的时候都认为别人不会修改, 所以不会上锁, 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据)
    -   乐观锁的常见实现方式包括<u>版本号控制和 CAS（Compare and Swap）算法</u>。在版本号控制中，每个共享资源都有一个版本号，线程在更新资源时会比较当前版本号和之前获取的版本号是否一致；在 CAS 算法中，线程会尝试原子地比较共享资源的当前值和期望值，如果相等则进行更新，否则重试。



## 如何实现乐观锁？

乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。

### 版本号机制

一般是在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。当数据被修改时，`version` 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 `version` 值相等时才更新，否则重试更新操作，直到更新成功。

**举一个简单的例子**：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ `balance` ）为 $100 。

1.  操作员 A 此时将其读出（ `version`=1 ），并从其帐户余额中扣除 50（100-$50 ）。
2.  在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ `version`=1 ），并从其帐户余额中扣除 20（100-$20 ）。
3.  操作员 A 完成了修改工作，将数据版本号（ `version`=1 ），连同帐户扣除后余额（ `balance`=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 `version` 更新为 2 。
4.  操作员 B 完成了操作，也将版本号（ `version`=1 ）试图向数据库提交数据（ `balance`=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。

这样就避免了操作员 B 用基于 `version`=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。

### CAS 算法

CAS 是 Compare And Swap 的缩写，中文意思是比较并交换。CAS 是一种用于实现多线程同步的<u>原子操作</u>，通常用于解决多线程并发访问共享数据时的线程安全性问题。

CAS 操作包括三个操作数：

1.  内存地址（或者说是变量的引用）：用来指定需要进行操作的内存地址。
2.  旧的预期值：表示当前内存地址上期望的值。
3.  新的值：表示期望更新后的新值。

CAS 操作的执行过程如下：

1.  首先，CPU 会从内存中读取当前内存地址的值，并将该值与旧的预期值进行比较。
2.  如果当前内存地址的值等于旧的预期值，则将新的值写入内存地址，并返回操作成功；否则，不做任何操作，直接返回操作失败。



## CAS 有什么缺点

1.  **ABA 问题**：ABA 问题是 CAS 原子操作中的一个经典问题。<u>假设一个线程在执行 CAS 操作之前读取了内存地址的值 A，然后另一个线程修改了该内存地址的值为 B，接着又将值修改回 A</u>。在这种情况下，CAS 操作会错误地认为内存地址的值没有发生改变，因为它仅仅比较了当前值与预期值。为了解决 ABA 问题，通常需要使用带版本号的 CAS 操作，如 `AtomicStampedReference` 或 `AtomicMarkableReference`。
2.  **自旋次数限制**：CAS 操作是一个自旋操作，即在操作失败时会一直尝试执行 CAS 操作直到成功。<u>如果线程竞争激烈或者操作频繁失败，就会导致线程一直自旋，浪费 CPU 资源</u>。为了避免无限自旋，通常会在 CAS 操作中设置自旋次数的限制。
3.  **只能保证单个变量的原子性**：<u>CAS 操作仅能保证对单个变量的原子性操作，无法保证多个变量之间的复合操作的原子性</u>。如果需要对多个变量进行复合操作，需要通过加锁等其他手段来保证原子性。