## ReentrantLock 是什么

可重入锁（Reentrant Lock）是一种用于多线程编程的锁机制，它允许同一个线程多次获取同一把锁，而不会导致死锁。可重入锁确保了在同一个线程内，已经获得锁的代码可以再次获得锁，从而使递归调用和循环调用变得安全。

以下是可重入锁的几个关键特点和作用：

1.  **递归调用安全**：可重入锁允许同一个线程在持有锁的情况下再次获得锁，这对于递归函数非常重要。否则，递归调用会在第二次尝试获取锁时导致死锁。
2.  **计数机制**：可重入锁内部维护一个计数器，用来记录同一个线程对该锁的获取次数。每当线程获取锁时，计数器增加；每当线程释放锁时，计数器减少。只有当计数器归零时，锁才真正被释放。
3.  **避免死锁**：由于同一个线程可以多次获取锁，可重入锁避免了在单个线程内的死锁问题。这在某些复杂的多线程程序中尤为重要。
4.  **线程独占**：虽然可重入锁允许同一线程多次获取锁，但它仍然是独占锁，即在一个线程持有锁时，其他线程必须等待，直到该锁被完全释放。



## Synchronized 和 ReentrantLock 有什么不同

`Synchronized` 和 `ReentrantLock` 都是 Java 中用于实现线程同步的机制，它们都可以保证多个线程对共享资源的安全访问，但在实现和使用上有一些不同之处：

1.  **性能**：
    -   <u>在低并发的情况下，`synchronized` 的性能通常比较好</u>，因为它是 JVM 层面的内置语言特性，在锁的申请和释放上有很多优化。
    -   <u>在高并发的情况下，`ReentrantLock` 的性能可能会比较好</u>，因为它提供了更多的功能和灵活性，并且可以通过手动控制锁的申请和释放来优化性能。
2.  **可中断性**：
    -   <u>`ReentrantLock` 提供了可中断的锁获取机制，即在等待锁的过程中，可以响应中断信号，也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。而 `synchronized` 不支持可中断性</u>。
3.  **公平性**：
    -   <u>`ReentrantLock` 提供了公平锁和非公平锁两种方式，默认情况下是非公平锁。而 `synchronized` 关键字只能使用非公平锁，即无法保证线程获取锁的公平性</u>。
4.  **条件等待**：
    -   <u>`ReentrantLock` 提供了 `Condition` 接口</u>，可以通过 `await()`、`signal()` 和 `signalAll()` 方法实现线程间的条件等待和通知机制，而 `synchronized` 并没有直接提供这样的功能。
5.  **灵活性**：
    -   <u>`ReentrantLock` 提供了更多的高级功能</u>，比如可重入性、超时等待、公平锁、条件等待等，使得它在一些特定的场景下更加灵活和强大。

总的来说，`synchronized` 是 Java 中的一种基本的内置锁机制，简单易用，在低并发情况下性能良好；而 `ReentrantLock` 是 `Lock` 接口的实现类，提供了更多的高级功能，可以满足一些特定的需求，但使用起来相对复杂一些。选择使用哪种锁机制取决于具体的场景和需求。



## 公平锁和非公平锁有什么区别？

-   **公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
-   **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。