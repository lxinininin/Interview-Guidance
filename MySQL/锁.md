## 锁的种类

1.   **共享锁 (Shared Lock)**: 

     允许多个事务同时获得共享锁, 可以进行读操作, 但不能进行写操作; 不堵塞, 多个用户可以同一时刻读取同一个资源, 相互之间没有影响

2.   **排他锁 (Exclusive Lock)**:

     一个事务获得排他锁后, 其他事务不能进行任何读或写操作, 这样可以只允许一个用户进行写入, 防止其他用户读取正在写入的资源

3.   **表锁 (Table Lock)**: 系统开销最小, 会锁定整张表, MyISAM 使用表锁

4.   **行锁 (Row Lock)**: 容易出现死锁, 发生冲突概率低, 并发高, InnoDB 支持行锁 (必须有索引才能实现, 否则会自动锁全表, 那么就不是行锁了)



## 说说什么是锁升级

锁升级（Lock Escalation）是数据库管理系统（DBMS）在资源争用激烈或系统资源紧张时，将细粒度的锁（如行锁）升级为粗粒度的锁（如页锁或表锁）的一种机制。锁升级通常用于减少系统的锁管理开销和提升整体性能，但可能会降低并发性。

*   <u>MySQL 行锁只能加在索引上, 如果操作不走索引, 就会升级为表锁</u>; 因为 InnoDB 的行锁是加在索引上的, 如果不走索引, 自然就没法使用行锁了, 原因是 InnoDB 是将 Primary Key Index 和相关的行数据共同放在 B+ 树的叶节点; InnoDB 一定会有一个 Primary Key, Secondary Index 查找的时候, 也是通过找到对应的 Primary, 再找对应的数据行
*   <u>当非唯一索引上记录树超过一定数量时, 行锁也会升级为表锁</u>; 测试发现当非唯一索引相同的内容不少于整个表记录的二分之一时会升级为表锁; 因为当非唯一索引相同的内容达到整个记录的二分之一时, 索引需要的性能比全文检索还要大, 查询语句优化时会选择不走索引, 造成索引失效, 行锁自然就会升级为表锁



## 悲观锁和乐观锁

*   **悲观锁（Pessimistic Locking）**: 

    悲观锁是一种严格的并发控制机制，假设并发冲突频繁发生。因此，每次对数据进行操作之前，都会先加锁，确保其他事务无法对数据进行修改，<u>直到当前事务完成并释放锁</u>。悲观锁通常依赖数据库系统的锁机制，如行锁、表锁等。

*   **乐观锁（Optimistic Locking）**: 

    乐观锁是一种宽松的并发控制机制，假设并发冲突很少发生。因此，在数据操作时不加锁，而是在<u>提交数据时检查是否有冲突</u>。如果检测到冲突，则回滚并重试。乐观锁通常使用版本号或时间戳来检测冲突。



## 怎样尽量避免死锁的出现

1.   **保持事务简短**

     尽量减少事务中包含的操作数量和执行时间，尽快提交或回滚事务。事务运行时间越短，持有锁的时间越短，死锁的可能性就越低。

2.   **按固定顺序访问资源**

     确保所有事务以相同的顺序访问数据库资源（如表、行等）。这样可以避免两个事务在相反的顺序上获取锁，从而减少死锁的可能性。

3.   **尽量减少锁的粒度**

     只锁定必要的数据。比如，使用行级锁而不是表级锁，减少锁的覆盖范围，降低锁冲突的概率。

4.   **使用合适的隔离级别**

     根据实际需要选择合适的事务隔离级别。较低的隔离级别（如读已提交）可能会减少死锁的发生，但要权衡数据一致性需求。

5.   **避免长时间持有锁**

     在事务中，尽量避免长时间持有锁的操作，如用户输入、复杂计算等。可以先获取必要的数据，释放锁后再进行长时间操作，然后再重新获取锁进行更新。

6.   **合理使用索引**

     使用索引可以加速查询，减少锁定的时间和范围，降低死锁的概率。

7.   **使用乐观锁**

     在并发冲突较少的场景下，使用乐观锁（通过版本号或时间戳）可以避免加锁，减少死锁的发生。

8.   **检测和处理死锁**

     数据库管理系统通常具备自动检测和处理死锁的机制。当检测到死锁时，会主动回滚其中一个事务来解除死锁。可以在应用程序中捕获死锁异常，并进行重试逻辑处理。

9.   **避免批量操作在一个事务中**

     大批量的更新、删除或插入操作，可能会持有大量锁，从而增加死锁的概率。可以将这些操作拆分成多个小的事务来执行。